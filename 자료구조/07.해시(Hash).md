# 해시

# 해시의 개념

해시(Hash)란, 데이터를 고정된 크기의 고유한 값으로 변환시키는 함수이다.

데이터의 무결성 검증이나 데이터의 일치 여부를 확인하기 위해 사용한다. 보안, 검색, 데이터베이스 등 다양한 분야에서 사용된다.

## 해시 함수의 특징

- 입력값이 조금만 변해도 출력값이 달라진다.
- 출력값을 통해 입력값을 유추하기 어렵다.
- 동일한 입력값에 대해서는 항상 동일한 출력값을 반환한다.

이러한 특징으로 인해 해시는 보안 문제에서 많이 사용되며, 비밀번호의 암호화나 인증 과정에서도 사용한다.

하지만, 해시 함수는 입력값이 같은 경우 항상 같은 출력값을 반환하기 때문에, 해시값을 미리 계산해놓은 해시테이블에서는 충돌이 발생할 수 있어 충돌을 방지하기 위해서 충돌을 최소화할 수 있는 해시함수를 사용해야한다. (밑에 해시테이블을 참고)

✅ **해시 충돌이란?**

해시 함수가 서로 다른 두 개의 입력값에 대해 동일한 출력값을 내는 상황

# HashMap

HashMap 은 java 에서 제공하는 해시 자료구조이다.

Key-Value 쌍으로 이루어져 있으며, Key를 인덱스로 사용하여 값을 저장한다.

## HashMap 의 특징

- Key 는 중복될 수 없으며, Value 는 중복될 수 있다.
- null 값을 허용한다.
- 순서를 보장하지 않는다.
- 많은 양의 데이터를 빠르게 검색할 수 있다.
- 삽입과 삭제도 빠르게 가능하지만, 해시 충돌이 발생할 경우 검색 성능이 저하될 수 있으므로 충돌을 최소화할 수 있는 해시함수를 사용해야 한다.

# HashSet

HashSet 은 java 에서 제공하는 해시 자료구조 중 하나로, 중복되지 않는 요소들을 저장하는 집합을 구현하며, 내부적으로 HashMap 을 사용한다.

## HashSet 의 특징

- 요소들은 순서를 보장하지 않는다.
- null 값을 허용한다.
- 중복된 값은 허용하지 않는다.
- 데이터베이스나 파일 시스템 등에서 중복된 값을 제거하거나, 대용량 데이터 중에서 특정 값을 찾을 때 유용하게 사용할 수 있다.

## HashSet 제공 메서드

Set 인터페이스를 구현하기 때문에 Set 이 제공하는 메서드를 사용할 수 있다.

- `add(E e)`: 지정된 요소를 HashSet에 추가
- `clear()`: HashSet에서 모든 요소를 제거
- `contains(Object o`): 지정된 요소가 HashSet에 포함되어 있는지 확인
- `isEmpty()`: HashSet이 비어있는지 확인
- `iterator()`: HashSet의 요소를 반복하는 Iterator를 반환
- `remove(Object o)`: 지정된 요소를 HashSet에서 제거
- `size()`: HashSet에 저장된 요소의 개수를 반환

HashSet 을 사용할 때는, 중복된 값을 제거하고 순서를 보장하지 않는 요소들을 저장하는 집합을 구현할 수 있다. 하지만 해시 충돌이 발생할 경우 검색 성능이 저하될 수 있으므로, 충돌을 최소화할 수 있는 해시함수를 사용해야한다.

# Hash Table

해시테이블은 해시 함수를 사용하여 Key 와 Value 를 연결하는 자료구조이다.

`HashMap`이라고도 불린다!

![해시테이블과 해시함수의 역할을 나타내는 개념도.](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F12afb2db-fd87-43d4-a4db-85dfee461aa7%2FUntitled.png?table=block&id=c5b9f23f-e2f4-44a9-bd51-721e8109571d&spaceId=d8c31e41-0ab8-4798-b72a-e6d973bbe9ad&width=700&userId=4bd117a6-cbe9-477e-b951-0dbf84a94dcf&cache=v2)

해시테이블과 해시함수의 역할을 나타내는 개념도.

## 해시테이블의 특징

- 해시 함수를 사용하여 키와 값이 저장될 위치를 계산하기 때문에 검색, 삽입, 삭제 모두 O(1) 시간복잡도를 가진다.
- 하지만 이 또한 해시 충돌이 발생할 경우 검색 성능이 저하될 수 있으므로, 충돌을 최소화할 수 있는 해시함수를 사용해야 하고 해시 테이블은 키(Key)와 값(Value)을 1:1 대응시키는 구조이기 때문에, 키와 값 모두 유일해야 한다.

## 구현 방법

Java 에서는 해시 테이블을 구현하기 위해 Hashtable, HashMap, LinkedHashMap, ConcurrentHashMap 등 다양한 클래스를 제공한다. 각 특징과 용도에 따라 적합한 클래스를 선택하여 사용하면 된다.

- `Hashtable`은 Java에서 가장 오래된 해시 테이블 클래스이며, 동기화를 보장하기 때문에 멀티스레드 환경에서 안전하게 사용할 수 있지만 동기화로 인한 성능 저하가 발생할 수 있습니다.
- `HashMap`은 Hashtable보다 빠른 검색 속도와 삽입/삭제 속도를 가지고 있지만 동기화를 보장하지 않기 때문에 멀티스레드 환경에서 안전하게 사용하기 위해서는 ConcurrentHashMap을 사용해야 함.
- `ConcurrentHashMap`은 멀티스레드 환경에서 안전하게 사용할 수 있는 해시 테이블 클래스. 동시성을 보장하기 위해 분할 잠금을 사용하므로, 여러 스레드가 동시에 접근해도 성능이 저하되지 않음.
- `LinkedHashMap`은 삽입 순서를 보장하기 때문에, 순서에 따라 데이터를 처리해야 하는 경우에 유용.

# 해시 충돌 해결 방법 (collision 해결)

## Separate chaining (체이닝)

버켓 내에 연결리스트(Linked List)를 할당하여, 버켓에 데이터를 삽입하다가 **해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식**

- Linked list 또는 Tree 를 사용해 충돌을 해결한다.
- 충돌이 발생하면 Linked list 에 노드를 추가하여 데이터를 저장한다.

![체이닝 해결의 예제.](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbab85976-3b7e-4b44-a915-f8edaf478ff3%2FUntitled.png?table=block&id=1ac67a70-b20e-4c87-9ca8-939dc169dd7f&spaceId=d8c31e41-0ab8-4798-b72a-e6d973bbe9ad&width=700&userId=4bd117a6-cbe9-477e-b951-0dbf84a94dcf&cache=v2)

체이닝 해결의 예제.

## open addressing (개방 주소법)

체이닝의 경우 버켓이 꽉 차더라도 연결리스트로 계속 늘려가기에, 데이터의 주소값은 바뀌지 않는다.(Closed Addressing) 하지만 개방 주소법의 경우에는 다르다. **해시 충돌이 일어나면 다른 버켓에 데이터를 삽입하는 방식**을 개방 주소법이라고 한다.

- 충돌 발생 시, 미리 정한 규칙에 따라 해시테이블의 비어있는 slot을 찾는다.
- 추가적인 메모리를 사용하지 않으므로 Linked list 또는 Tree 자료구조를 통해 추가로 메모리를 할당하는 separate chaining 방식에 비해 메모리를 적게 사용한다.

### 개방 주소법의 대표적 3가지

- **선형 탐색(Linear Probing):** 해시충돌 시 다음 버켓, 혹은 몇 개를 건너뛰어 데이터를 삽입한다.
- **제곱 탐색(Quadratic Probing):** 해시충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입(1,4,9,16..)
- **이중 해시(Double Hashing):** 해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용함.